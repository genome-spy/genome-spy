import { LitElement, css, html, nothing } from "lit";
import { autoUpdate, computePosition, flip, offset } from "@floating-ui/dom";
import { formStyles } from "./componentStyles.js";

let nextElementId = 0;

/**
 * @typedef {{ id: string, label?: string }} MultiSelectOption
 * @typedef {string | MultiSelectOption} MultiSelectSearchResult
 */

/**
 * @param {MultiSelectSearchResult} result
 * @returns {MultiSelectOption}
 */
function normalizeResult(result) {
    if (typeof result === "string") {
        return { id: result, label: result };
    }

    return {
        id: result.id,
        label: result.label ?? result.id,
    };
}

/**
 * @param {string[]} values
 * @returns {string[]}
 */
function uniqueValues(values) {
    const seen = new Set();
    /** @type {string[]} */
    const deduplicated = [];

    for (const value of values) {
        const normalized = String(value).trim();
        if (normalized.length === 0 || seen.has(normalized)) {
            continue;
        }
        seen.add(normalized);
        deduplicated.push(normalized);
    }

    return deduplicated;
}

/**
 * Searchable multi-select input for choosing multiple string values with
 * typeahead suggestions, pill/tag rendering, and keyboard-first navigation.
 *
 * This implementation was generated by Codex and is inspired by the UX
 * patterns popularized by Selectize.js and Choices.js.
 */
export default class MultiSelect extends LitElement {
    static properties = {
        selectedValues: { attribute: false },
        search: { attribute: false },
        placeholder: { type: String },
        disabled: { type: Boolean },
        allowUnknown: { type: Boolean, attribute: "allow-unknown" },
        debounceMs: { type: Number, attribute: "debounce-ms" },
        maxSuggestions: { type: Number, attribute: "max-suggestions" },
        _query: { state: true },
        _loading: { state: true },
        _open: { state: true },
        _activeIndex: { state: true },
        _suggestions: { state: true },
        _inputHasFocus: { state: true },
    };

    static styles = [
        formStyles,
        css`
            :host {
                display: block;
            }

            .wrapper {
                position: relative;
            }

            .control {
                display: flex;
                flex-wrap: wrap;
                align-items: center;
                gap: 0.2em;
                width: 100%;
                box-sizing: border-box;
                padding: 0.3em 0.5em;
                font-size: 1em;
                line-height: 1.5;
                color: var(--form-control-color);
                background-color: #fff;
                border: var(--form-control-border);
                border-radius: var(--form-control-border-radius);
                transition:
                    border-color 0.15s ease-in-out,
                    box-shadow 0.15s ease-in-out;
                cursor: text;
            }

            :host(.is-invalid) .control {
                border-color: var(--danger-color, #dc3545);
                box-shadow: 0 0 0 0.2rem rgb(220 53 69 / 25%);
            }

            .pill {
                display: inline-flex;
                align-items: center;
                gap: 0.35em;
                max-width: 100%;
                background: #edf2f7;
                border: 1px solid #d4dce4;
                border-radius: 999px;
                padding: 0.1em 0.55em;
                font-size: 0.93em;
                line-height: 1.4;
            }

            .pill-label {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 18em;
            }

            .pill-remove {
                border: 0;
                background: transparent;
                color: #495057;
                font-size: 1.1em;
                line-height: 1;
                padding: 0;
                margin: 0;
                cursor: pointer;
            }

            .query {
                flex: 1;
                min-width: 8em;
                border: 0;
                outline: 0;
                padding: 0.1em 0.25em;
                margin: 0;
                background: transparent;
                font: inherit;
                color: inherit;
            }

            .query::placeholder {
                color: #a0a0a0;
            }

            .dropdown {
                position: fixed;
                margin: 0;
                inset: auto;
                max-height: 16rem;
                overflow: auto;
                border: var(--form-control-border);
                border-radius: var(--form-control-border-radius);
                background: #fff;
                box-shadow: 0 6px 16px rgb(0 0 0 / 12%);
                padding: 0.2em 0;
            }

            .option {
                padding: 0.35em 0.75em;
                cursor: pointer;
            }

            .option.active {
                background: #eef3ff;
                outline: 2px solid #c6dbff;
                outline-offset: -2px;
            }

            .status {
                padding: 0.35em 0.75em;
                color: #6c757d;
                font-size: 0.92em;
            }

            .control.disabled {
                background-color: #f4f4f4;
                cursor: default;
            }

            .control.disabled .pill-remove,
            .control.disabled .query {
                cursor: default;
            }
        `,
    ];

    /** @type {string} */
    #listboxId;

    /** @type {number | null} */
    #debounceTimer;

    /** @type {number} */
    #searchVersion;

    /** @type {(() => void) | null} */
    #cleanupAutoUpdate;

    constructor() {
        super();
        this.selectedValues = [];
        this.search = null;
        this.placeholder = "Type to search";
        this.disabled = false;
        this.allowUnknown = false;
        this.debounceMs = 180;
        this.maxSuggestions = 50;
        this._query = "";
        this._loading = false;
        this._open = false;
        this._activeIndex = -1;
        this._suggestions = [];
        this._inputHasFocus = false;

        this.#listboxId = "gs-multiselect-listbox-" + String(nextElementId++);
        this.#debounceTimer = null;
        this.#searchVersion = 0;
        this.#cleanupAutoUpdate = null;
    }

    disconnectedCallback() {
        super.disconnectedCallback();
        this.#clearDebounceTimer();
        this.#stopPositionTracking();
    }

    /**
     * @param {import("lit").PropertyValues<this>} changed
     */
    willUpdate(changed) {
        if (changed.has("selectedValues")) {
            this.selectedValues = uniqueValues(
                Array.from(this.selectedValues, (value) => String(value))
            );
            this.#updateSuggestionVisibility();
        }
    }

    /**
     * @param {import("lit").PropertyValues<this>} changed
     */
    updated(changed) {
        if (changed.has("_open")) {
            this.#syncPopoverVisibility();
        }

        if (changed.has("_activeIndex")) {
            this.#scrollActiveIntoView();
        }

        if (
            this._open &&
            (changed.has("_suggestions") || changed.has("_loading"))
        ) {
            this.#updatePopoverPosition();
        }
    }

    get value() {
        return this.selectedValues;
    }

    /**
     * @param {string[]} values
     */
    set value(values) {
        this.selectedValues = uniqueValues(values);
    }

    focus() {
        this.#focusInput();
    }

    /**
     * @param {string} query
     */
    #queueSearch(query) {
        this.#clearDebounceTimer();
        this.#debounceTimer = window.setTimeout(
            () => void this.#executeSearch(query),
            this.debounceMs
        );
    }

    #clearDebounceTimer() {
        if (this.#debounceTimer !== null) {
            window.clearTimeout(this.#debounceTimer);
            this.#debounceTimer = null;
        }
    }

    /**
     * @param {string} query
     */
    async #executeSearch(query) {
        if (!this.search) {
            this._suggestions = [];
            this._loading = false;
            this._activeIndex = -1;
            this._open = false;
            return;
        }

        const version = ++this.#searchVersion;
        this._loading = true;
        this._open = this._inputHasFocus;

        try {
            const results = await this.search(query);
            if (version !== this.#searchVersion || query !== this._query) {
                return;
            }

            const selected = new Set(this.selectedValues);
            /** @type {MultiSelectOption[]} */
            const suggestions = [];

            for (const result of results) {
                const option = normalizeResult(result);
                if (selected.has(option.id)) {
                    continue;
                }
                suggestions.push(option);
                if (suggestions.length >= this.maxSuggestions) {
                    break;
                }
            }

            this._suggestions = suggestions;
            this._activeIndex = suggestions.length > 0 ? 0 : -1;
            this._open = this._inputHasFocus;
        } finally {
            if (version === this.#searchVersion) {
                this._loading = false;
            }
        }
    }

    #focusInput() {
        /** @type {HTMLInputElement | null} */
        const input = this.renderRoot.querySelector("input.query");
        input?.focus();
    }

    #controlEl() {
        return /** @type {HTMLElement | null} */ (
            this.renderRoot.querySelector(".control")
        );
    }

    #dropdownEl() {
        return /** @type {HTMLElement | null} */ (
            this.renderRoot.querySelector("#" + this.#listboxId)
        );
    }

    /**
     * @param {string} id
     */
    #optionDomId(id) {
        return this.#listboxId + "-opt-" + id;
    }

    #scrollActiveIntoView() {
        if (this._activeIndex < 0 || !this._open) {
            return;
        }
        /** @type {HTMLElement | null} */
        const active = this.renderRoot.querySelector(
            "#" + this.#optionDomId(String(this._activeIndex))
        );
        active?.scrollIntoView({ block: "nearest" });
    }

    #updatePopoverPosition() {
        const control = this.#controlEl();
        const dropdown = this.#dropdownEl();
        if (!control || !dropdown || !this._open) {
            return;
        }

        const width = control.getBoundingClientRect().width;
        dropdown.style.minWidth = String(width) + "px";

        computePosition(control, dropdown, {
            placement: "bottom-start",
            strategy: "fixed",
            middleware: [offset(4), flip()],
        }).then(({ x, y }) => {
            if (!this._open) {
                return;
            }
            dropdown.style.left = String(x) + "px";
            dropdown.style.top = String(y) + "px";
        });
    }

    #startPositionTracking() {
        const control = this.#controlEl();
        const dropdown = this.#dropdownEl();
        if (!control || !dropdown) {
            return;
        }

        this.#stopPositionTracking();
        this.#updatePopoverPosition();
        this.#cleanupAutoUpdate = autoUpdate(control, dropdown, () =>
            this.#updatePopoverPosition()
        );
    }

    #stopPositionTracking() {
        if (!this.#cleanupAutoUpdate) {
            return;
        }
        this.#cleanupAutoUpdate();
        this.#cleanupAutoUpdate = null;
    }

    #syncPopoverVisibility() {
        const dropdown = this.#dropdownEl();
        if (!dropdown) {
            return;
        }

        const supportsPopover =
            typeof dropdown.showPopover === "function" &&
            typeof dropdown.hidePopover === "function";

        if (this._open) {
            if (supportsPopover && !dropdown.matches(":popover-open")) {
                dropdown.showPopover();
            }
            this.#startPositionTracking();
        } else {
            this.#stopPositionTracking();
            if (supportsPopover && dropdown.matches(":popover-open")) {
                dropdown.hidePopover();
            }
        }
    }

    #updateSuggestionVisibility() {
        const selected = new Set(this.selectedValues);
        this._suggestions = this._suggestions.filter(
            (suggestion) => !selected.has(suggestion.id)
        );
        if (this._suggestions.length === 0) {
            this._activeIndex = -1;
        } else if (this._activeIndex >= this._suggestions.length) {
            this._activeIndex = this._suggestions.length - 1;
        }
    }

    #emitChange() {
        this.dispatchEvent(
            new MultiSelectChangeEvent(Array.from(this.selectedValues))
        );
    }

    /**
     * @param {string} id
     */
    #addValue(id) {
        const value = String(id).trim();
        if (value.length === 0 || this.selectedValues.includes(value)) {
            return;
        }

        this.selectedValues = [...this.selectedValues, value];
        this.#emitChange();
    }

    /**
     * @param {string} id
     */
    #removeValue(id) {
        const next = this.selectedValues.filter((value) => value !== id);
        if (next.length === this.selectedValues.length) {
            return;
        }
        this.selectedValues = next;
        this.#emitChange();
    }

    #removeLastValue() {
        if (this.selectedValues.length === 0) {
            return;
        }
        this.selectedValues = this.selectedValues.slice(
            0,
            this.selectedValues.length - 1
        );
        this.#emitChange();
    }

    /**
     * @param {string} query
     * @returns {MultiSelectOption | null}
     */
    #findExactMatch(query) {
        const lower = query.toLowerCase();
        return (
            this._suggestions.find(
                (suggestion) => suggestion.id.toLowerCase() === lower
            ) ?? null
        );
    }

    #confirmSelection() {
        const active =
            this._activeIndex >= 0 &&
            this._activeIndex < this._suggestions.length
                ? this._suggestions[this._activeIndex]
                : null;
        const query = this._query.trim();

        if (active) {
            this.#addValue(active.id);
        } else if (query.length > 0) {
            const exact = this.#findExactMatch(query);
            if (exact) {
                this.#addValue(exact.id);
            } else if (this.allowUnknown) {
                this.#addValue(query);
            }
        }

        this._query = "";
        this.#queueSearch("");
        this.#focusInput();
    }

    /**
     * @param {MouseEvent} event
     */
    #onControlMouseDown(event) {
        if (this.disabled) {
            return;
        }

        if (
            event.target instanceof HTMLElement &&
            event.target.closest(".pill-remove")
        ) {
            return;
        }

        event.preventDefault();
        this.#focusInput();
    }

    /**
     * @param {InputEvent} event
     */
    #onInput(event) {
        const input =
            /** @type {HTMLInputElement | null} */
            (event.currentTarget);
        if (!input) {
            return;
        }

        this._query = input.value;
        this.#queueSearch(this._query);
        this._open = true;
    }

    #onInputFocus() {
        this._inputHasFocus = true;
        this._open = true;
        this.#queueSearch(this._query);
    }

    #onInputBlur() {
        this._inputHasFocus = false;
    }

    /**
     * @param {KeyboardEvent} event
     */
    #onInputKeyDown(event) {
        if (this.disabled) {
            return;
        }

        if (event.key === "ArrowDown" || event.key === "ArrowUp") {
            event.preventDefault();
            event.stopPropagation();

            if (this._suggestions.length === 0) {
                return;
            }

            if (this._activeIndex < 0) {
                this._activeIndex = 0;
                return;
            }

            const direction = event.key === "ArrowDown" ? 1 : -1;
            const next = Math.max(
                0,
                Math.min(
                    this._suggestions.length - 1,
                    this._activeIndex + direction
                )
            );
            this._activeIndex = next;
            return;
        }

        if (event.key === "Enter") {
            event.preventDefault();
            event.stopPropagation();
            this.#confirmSelection();
            return;
        }

        if (event.key === "Backspace" && this._query.length === 0) {
            event.stopPropagation();
            this.#removeLastValue();
            return;
        }

        if (event.key === "Tab") {
            this._open = false;
            this._activeIndex = -1;
            return;
        }

        if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            this._open = false;
            this._activeIndex = -1;
        }
    }

    /**
     * @param {number} index
     */
    #selectSuggestionByIndex(index) {
        const suggestion = this._suggestions[index];
        if (!suggestion) {
            return;
        }

        this.#addValue(suggestion.id);
        this._query = "";
        this.#queueSearch("");
        this._activeIndex = 0;
        this.#focusInput();
    }

    render() {
        const activeId =
            this._activeIndex >= 0
                ? this.#optionDomId(String(this._activeIndex))
                : nothing;

        return html`
            <div class="wrapper">
                <div
                    class="control ${this.disabled ? "disabled" : ""}"
                    @mousedown=${(/** @type {MouseEvent} */ event) =>
                        this.#onControlMouseDown(event)}
                >
                    ${this.selectedValues.map(
                        (value) =>
                            html`<span class="pill">
                                <span class="pill-label">${value}</span>
                                <button
                                    class="pill-remove"
                                    type="button"
                                    aria-label=${"Remove " + value}
                                    ?disabled=${this.disabled}
                                    @click=${() => {
                                        this.#removeValue(value);
                                        this.#focusInput();
                                    }}
                                >
                                    Ã—
                                </button>
                            </span>`
                    )}

                    <input
                        class="query"
                        type="text"
                        role="combobox"
                        aria-controls=${this.#listboxId}
                        aria-expanded=${this._open ? "true" : "false"}
                        aria-autocomplete="list"
                        aria-activedescendant=${activeId}
                        placeholder=${this.placeholder}
                        .value=${this._query}
                        ?disabled=${this.disabled}
                        @focus=${() => this.#onInputFocus()}
                        @blur=${() => this.#onInputBlur()}
                        @input=${(/** @type {InputEvent} */ event) =>
                            this.#onInput(event)}
                        @keydown=${(/** @type {KeyboardEvent} */ event) =>
                            this.#onInputKeyDown(event)}
                    />
                </div>

                <div
                    id=${this.#listboxId}
                    class="dropdown"
                    popover="auto"
                    ?hidden=${!this._open}
                    role="listbox"
                    @toggle=${(/** @type {ToggleEvent} */ event) => {
                        if (event.newState === "closed" && this._open) {
                            this._open = false;
                            this._activeIndex = -1;
                        }
                    }}
                >
                    ${this._loading
                        ? html`<div class="status">Loading...</div>`
                        : nothing}
                    ${!this._loading && this._suggestions.length === 0
                        ? html`<div class="status">No matches</div>`
                        : nothing}
                    ${this._suggestions.map(
                        (suggestion, index) =>
                            html`<div
                                id=${this.#optionDomId(String(index))}
                                class="option ${index === this._activeIndex
                                    ? "active"
                                    : ""}"
                                role="option"
                                aria-selected=${index === this._activeIndex
                                    ? "true"
                                    : "false"}
                                @mousedown=${(
                                    /** @type {MouseEvent} */ event
                                ) => event.preventDefault()}
                                @mouseenter=${() => {
                                    this._activeIndex = index;
                                }}
                                @click=${() =>
                                    this.#selectSuggestionByIndex(index)}
                            >
                                ${suggestion.label ?? suggestion.id}
                            </div>`
                    )}
                </div>
            </div>
        `;
    }
}

customElements.define("gs-multi-select", MultiSelect);

/**
 * @extends {Event}
 */
export class MultiSelectChangeEvent extends Event {
    /** @type {string[]} */
    values;

    /**
     * @param {string[]} values
     */
    constructor(values) {
        super("change", { bubbles: true, composed: true });
        this.values = values;
    }
}
