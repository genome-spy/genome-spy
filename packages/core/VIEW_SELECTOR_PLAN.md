# View / Parameter Selector Refactor Plan

## Goals

- Stop requiring globally-unique `name` across the entire view specification.
- Make shareable/bookmarkable state robust when templates are imported multiple times.
- Define a stable, spec-author-controlled addressing scheme for:
  - toggleable view visibility (`configurableVisibility`)
  - user-facing parameter state (bound inputs and selection parameters)

This plan intentionally avoids converting view visibility into parameters (for now). Instead, it introduces selector keys that are compatible with the current bookmark model while enabling a future migration toward a more parameter-centric state model.

## Terminology

- **Explicit name**: a name authored in the spec (`spec.name`). For runtime, this is exposed as `View.explicitName`.
- **Auto-generated name**: a debug-only name assigned by the parent/factory. For runtime, this is exposed as `View.defaultName`.
- **Effective name**: `View.name = View.explicitName ?? View.defaultName`.
- **Import instance**: an `ImportSpec` instantiation (template or URL import).
- **Scope frame / import scope**: the “namespace” created by an import instance.
- **Scope chain**: nested import scopes as an array of import-instance names.
- **Addressable feature**: something that users expect to be bookmarkable/shareable:
  - a view with `configurableVisibility: true`
  - a parameter with `bind`
  - a selection parameter (`select`)

Selectors must use only explicit names. Auto-generated names are never part of the public addressing contract.

## Current Behavior & Constraints

### Why the current approach breaks

GenomeSpy currently relies on `view.name` behaving like a globally-unique identifier in several places (notably the App’s view visibility persistence and a few view lookups). This breaks down when view subtrees are reused via templates or URL imports, because importing the same template multiple times naturally produces duplicate names.

Parameter state is also a constraint: parameter lookup walks the view’s ancestor chain (nearest definition wins). Duplicate parameter names are allowed and useful during spec construction, but user-facing parameters create an expectation of bookmarkability/shareability.

### Imports (spec + implementation)

This plan is grounded in the existing spec and docs:

- Import docs: [docs/grammar/import.md](../../docs/grammar/import.md)
  - Templates are reused via `templates` + `{ "import": { "template": "..." } }`.
  - Import-site parameters (`ImportSpec.params`) override imported spec parameters.
- Type definition: [packages/core/src/spec/view.d.ts](src/spec/view.d.ts)
  - `ImportSpec.name` overrides the name specified in the imported specification.
  - `ImportSpec.params` supports both `Parameter[]` and an object shorthand.
- Implementation: view creation/import: [packages/core/src/view/viewFactory.js](src/view/viewFactory.js)
  - `applyParamsToImportedSpec` sets `importedSpec.name = importSpec.name`.
  - Templates are resolved by ascending the `dataParent` chain (this reflects the spec/data ancestry and avoids involving layout-only wrapper/decoration views; for most spec-authored views `dataParent` and `layoutParent` are the same).

Implication: `ImportSpec.name` already behaves like an “instance name” at the root of the imported subtree.

### Runtime naming (important for selectors)

Recent discussion and implementation work clarified that “name” mixes two concepts.

- `View.explicitName` = `spec.name` (author-controlled). For imports, `ImportSpec.name` becomes the explicit name of the imported subtree root.
- `View.defaultName` = auto-generated by the parent/factory (debug-only).
- `View.name` = `View.explicitName ?? View.defaultName`.

Auto-generated names should be produced by a per-container monotonic counter (e.g. `ContainerView.getNextAutoName(prefix)`), to avoid collisions during dynamic mutations. However, these names remain non-contractual and must not be used in bookmarks/selectors.

### App: `ViewAttributeSpecifier` currently relies on global name lookup

The App’s SampleView attribute system currently uses view names as if they were globally unique identifiers.

- Type definition: [packages/app/src/sampleView/sampleViewTypes.d.ts](../app/src/sampleView/sampleViewTypes.d.ts)
  - `BaseSpecifier.view: string`
- Resolution call sites:
  - [packages/app/src/sampleView/sampleView.js](../app/src/sampleView/sampleView.js)
    - resolves via `rootView.findDescendantByName(specifier.view)`
  - [packages/app/src/sampleView/viewAttributeInfoSource.js](../app/src/sampleView/viewAttributeInfoSource.js)
    - resolves via `rootView.findDescendantByName(specifier.view)` when constructing accessors

This breaks under template/import reuse for the same reasons as visibility persistence: multiple imported instances naturally produce duplicate explicit names (and auto-generated names are not stable/contracts).

Planned change (App-facing): evolve `ViewAttributeSpecifier.view` to accept either:

- legacy `string` (backward compatibility), or
- a structured selector object (not JSON-serialized) that matches explicit names only, e.g. `ViewSelector` `{ scope: string[], view: string }`.

Resolution semantics for attribute specifiers should be stricter than legacy visibility restore:

- Selector object: must resolve to exactly one addressable spec-authored view (typically a `UnitView`); error if not found.
- Legacy string: resolve by explicit name within the addressable tree; error if ambiguous (multiple matches) and recommend naming imports or updating the specifier to a selector object.

## Proposed Model: Import Scopes + Local Uniqueness

### Core idea

Treat each import instantiation as a **scope frame**. A selector is:

- an **import scope chain** (nesting-aware), plus
- a **local explicit identifier** within the final scope.

This eliminates the need for order-based selectors and avoids reliance on internal runtime nodes.

### What forms a scope frame?

A scope frame is created by every `ImportSpec` instantiation.

- If `ImportSpec.name` is provided, that string becomes the scope’s name (and the imported subtree root’s explicit name).
- If `ImportSpec.name` is omitted, the scope is _unnamed_.

Nested imports naturally produce a scope chain.

### Addressability and naming/uniqueness rules

Within a single scope instance, explicitly specified names need only be unique **within that scope**, not globally. To reduce author burden, enforce constraints only for addressable features.

1. **Configurable visibility**

- Views with `configurableVisibility: true` must have an explicit `name`.
- Those explicit names must be unique within the scope.

2. **User-facing parameters (bound + selections)**

- Persisted parameter identity is scoped similarly to view names.
- Bookmarkable parameter names (bound and selection parameters) must be unique within the import scope.

3. **Sibling import instances**

- If multiple sibling import instances under the same parent contain addressable features, each such import instance must have a unique `ImportSpec.name`.
- If there is only a single addressable import instance at that level, it may remain unnamed.

### Compatibility with current docs

Currently, docs and type comments say `configurableVisibility` requires `name` unique “within the view hierarchy/specification”. This plan changes that contract to:

- unique within the relevant **import scope instance**, and
- import instance names required only when there are multiple addressable sibling instances.

Docs and type comments will need to be updated accordingly.

## Selectors

### ViewSelector

A **ViewSelector** identifies a visibility-toggleable view (and any other UI-driven view operation that must be stable across imports).

- `scope: string[]` — chain of named import instances
- `view: string` — explicit view name (`View.explicitName`), unique within the scope

Example:

- `scope: ["patientPanel", "cnvTracks"], view: "coverage"`

Representation guidance:

- Bookmark / wire format: store the selector object as data (see “Persistence & Migration”).
- Internal representation: use a canonical string key for fast lookup (e.g. `"v:" + JSON.stringify({ s, v })`).

Resolution requirements:

- Resolution must match **explicit names only** (`View.explicitName`).
- Views that lack an explicit name are not addressable and must never match selectors.

### ParamSelector

A **ParamSelector** identifies a bookmarkable parameter within an import scope.

- `scope: string[]` — chain of named import instances
- `param: string` — parameter name (unique within the scope)

Example:

- `scope: ["patientPanel", "cnvTracks"], param: "brush"`

Representation guidance:

- Bookmark / wire format: store the selector object as data (see “Persistence & Migration”).
- Internal representation: use a canonical string key for fast lookup (e.g. `"p:" + JSON.stringify({ s, p })`).

### Addressable tree and import boundaries

The runtime view tree may include wrapper nodes (e.g. `implicitRoot`) and decoration/implementation nodes (axes, scrollbars).

Selector resolution must operate on an **addressable/logical tree** that:

- includes imported subtree roots and explicit spec views
- excludes decoration/implementation-only views

The selector system should introduce a dedicated traversal/resolution helper (rather than using global `findDescendantByName`). This also helps reduce the variety of ad hoc lookup helpers in App-facing code.

## Persistence & Migration (Bookmarks, URL Hash)

### Wire format vs internal representation

Use different shapes for:

- **Bookmark / URL payloads (wire format):** prefer arrays of entries with structured selector objects.
- **In-memory state / Redux (internal representation):** prefer maps/records keyed by a canonical string for fast lookup.

Rationale: JSON-string-as-object-key is convenient internally, but it is an awkward public/wire contract and makes it harder to extend payloads with additional fields.

### New bookmarks should always use selectors

The App currently stores `viewSettings.visibilities` keyed by `view.name` and includes this in shareable links/bookmarks.

Target behavior:

- When saving/sharing state, always write selector keys for:
  - configurable visibilities
  - bookmarkable parameter state

Recommended bookmark payload shapes:

- Visibilities: `[{ s: string[], v: string, on: boolean }]`
- Parameter state: `[{ s: string[], p: string, value: unknown }]` (exact `value` shape depends on the parameter type)

On restore, build internal lookup maps once (e.g. `Map` keyed by canonical string) and apply them efficiently.

### Legacy restore must still work

"Legacy" refers to bookmarks / URL hashes created before selectors existed. Those payloads store view visibility state as a plain mapping keyed by a view name string (the historical `view.name` contract), e.g.:

```json
{
  "viewSettings": {
    "visibilities": {
      "coverage": true,
      "variants": false
    }
  }
}
```

Restoration must continue to accept this legacy shape: `{ [viewName: string]: boolean }`.

- On restore:
  - If a key parses as a selector → resolve it.
  - Else treat as a legacy view name → apply legacy behavior (best-effort):
    - find all addressable views whose **explicit name** equals the legacy key and apply the boolean.
    - if the legacy key matches multiple views (possible with template reuse), apply it to all matches and optionally emit a warning that the legacy bookmark is ambiguous.

This approach does not require migrating legacy keys in Redux state.

### Two-phase restore consideration

The App performs an “early restore” of view visibility before initial data/scale initialization.

- Selector resolution may require a built view tree.
- If early restore happens before the tree exists, defer selector application until after launch, but still apply legacy name keys early if needed.

## Implementation Plan (Phased)

### Already done (groundwork)

- Clarified runtime naming semantics: explicit vs auto-generated vs effective name.
- Stabilized auto-generated names under dynamic mutations (per-container monotonic counters).

### Phase 0 — Spec contract and documentation alignment

- Align type comments and end-user docs with the terminology and scoped-uniqueness contract.

### Phase 0.5 — Legacy-compat test gate (do this early)

Legacy bookmarks (plain view-name keyed visibilities) must remain supported throughout the refactor. Add App tests first so later phases cannot regress compatibility.

- Add/lock in tests for legacy restore of visibilities keyed by plain strings.
- Include an ambiguity case (same explicit view name exists in multiple imported instances) and assert the documented behavior (apply to all matches and optionally warn).
- Keep these tests green as a gate for all later phases.

### Phase 1 — Core selector utilities (Core package)

Add utilities that:

- build scope-chain information for views created via `ImportSpec`
- enumerate “addressable” views (exclude decoration/internal nodes)
- resolve a selector `{s, v}` to a unique runtime view
- resolve a selector `{s, p}` to a unique bookmarkable parameter within the scope

These utilities should be pure and testable without App.

### Phase 2 — Validation of naming constraints

Validation is required for the App’s bookmarking/UI features, but it is not strictly required for Core’s rendering/dataflow. The recommended split is:

- Core provides reusable _validation utilities_ (pure functions) that can detect ambiguity and produce actionable messages.
- App invokes these utilities and treats violations as fatal errors (or warnings, depending on UX).
- Other Core consumers may opt in to the validation, but are not forced to.

Introduce validation (ideally as a Core utility, invoked by the App at a spec boundary):

- For each scope instance:
  - detect addressable features
  - if addressable and ambiguous:
    - require unique `ImportSpec.name` for sibling instances
  - ensure uniqueness of:
    - configurable view names within scope
    - bookmarkable parameter names within scope

Validation should fail fast with actionable error messages:

- “Multiple imported instances with configurable visibility require distinct import names”
- “View with configurableVisibility must have an explicit name”
- “Bookmarkable parameter ‘brush’ must be unique within the import scope”

Optional lightweight validation in Core (even without App) can still be beneficial for earlier feedback, e.g. checking for duplicate explicit names among sibling views in the same container when those views are intended to be addressable.

### Phase 3 — App integration (persistence)

- Change bookmark/URL serialization to emit selector keys for new bookmarks.
- Keep legacy restore compatibility.
- Update the visibility predicate and UI toggle logic to consult selector keys.

In the same App integration effort (or immediately after Phase 1 core utilities exist), migrate SampleView attribute specifiers to be selector-aware:

- Update `ViewAttributeSpecifier.view` to accept `string | ViewSelector` (object form, no JSON serialization).
- Replace `findDescendantByName`-based resolution with selector-based resolution on the addressable tree.
- Keep string support as a legacy compatibility path, but fail fast on ambiguity.

### Phase 4 — Parameter state persistence

- Define what parameter state is persisted:
  - bound inputs: current value
  - selections: selection value/state
- Add bookmark serialization/deserialization using ParamSelector keys.
- Ensure scoping/override behavior is preserved.

### Phase 5 — Cleanup and deprecation

- Deprecate any global “find by name” mechanisms used for bookmark/state features.
- Keep legacy restore paths, but consider removing legacy _writing_ over time.

## Testing

### Core tests (Vitest)

Add tests near relevant code (Core package) for:

- Template import scoping:
  - import the same template twice with different `ImportSpec.name`
  - ensure selectors resolve to different instances
- Unnamed import instance behavior:
  - single instance without addressable features → allowed
  - multiple instances with addressable features → error
- Scoped uniqueness:
  - duplicate view names across different import scopes → allowed
  - duplicate configurable view names within same scope → error
- Parameter selectors:
  - bound param and selection param are uniquely resolvable by `(scope, param)`
  - override via `ImportSpec.params` still yields stable identity

### App tests

Add tests for:

- Legacy bookmark restore still applies visibilities keyed by a plain view name string.
  - These tests should be implemented in Phase 0.5 (early) and treated as a compatibility gate.
- New bookmark save emits selector keys.
- Round-trip: save → restore yields same visible views and parameter states.

Add tests for `ViewAttributeSpecifier` resolution:

- Selector object resolves to the intended view under repeated template imports.
- Legacy string resolution errors on ambiguity and suggests using import names / selector object.

## Documentation

Update docs to match the new contract:

- [docs/grammar/import.md](../../docs/grammar/import.md)
  - Clarify that `ImportSpec.name` names the imported instance and participates in bookmark addressing.
  - Recommend naming imports when importing the same template multiple times and exposing bookmarkable state.
- [docs/grammar/parameters.md](../../docs/grammar/parameters.md)
  - Explain bookmarkability expectations for bound/selection parameters.
  - Describe scoping/override implications for persisted state.
- [docs/sample-collections/visualizing.md](../../docs/sample-collections/visualizing.md)
  - Update the “unique within the view specification” statement to “unique within the import scope instance”.
- Type comments in [packages/core/src/spec/view.d.ts](src/spec/view.d.ts)
  - Update `ViewSpecBase.name` and `configurableVisibility` docs to mention scoped uniqueness.
  - Optionally add clarifying notes to `ImportSpec.name` about scope/instance naming.

## Risks & Mitigations

- **Ambiguity when imports are unnamed**
  - Mitigation: require import instance naming only when multiple addressable instances exist.
- **Refactors that rename import instance names or view names break bookmarks**
  - Mitigation: treat these names as part of a public contract; document clearly; provide actionable error/warning messages.
- **Runtime tree contains implementation nodes that shift with refactors**
  - Mitigation: selector resolution operates on an addressable/logical tree, not the raw runtime view tree.
- **Early restore ordering (before view tree exists)**
  - Mitigation: define a two-phase restore pipeline; allow deferral for selector-based state.
- **Performance in large view trees**
  - Mitigation: precompute scope/lookup maps once after view creation; avoid repeated tree traversals per lookup.

## Definition of Success

A successful outcome looks like:

- New shareable URLs and saved bookmarks persist state using selector keys that remain stable under template reuse.
- The same template can be imported multiple times without requiring globally-unique names throughout the imported subtree.
- Naming constraints are minimal but strict where needed:
  - configurable visibility and user-facing parameters are always unambiguous.
  - importing the same bookmark-relevant subtree multiple times requires explicit import instance names.
- Legacy bookmarks that store visibilities keyed by plain `view.name` still restore sensibly.
- Tests cover:
  - nested imports
  - import-site name overrides
  - scoped uniqueness enforcement
  - bookmark round-trips for both visibilities and parameter states
